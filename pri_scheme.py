# Author: Casey Betts, 2023
# This tool models earth-imaging satellite capabilities and uses gradient descent to optimize how the satellite will choose imaging targets. 
# The prioritization scheme is considered optimized when the revenu generated by the model is maximized. The model is supplied with a list of orders
# all having specific location data and dollar amounts associated to them.

import json
import matplotlib.pyplot as plt
import pandas as pd

from math import exp
from numpy import random
from os import listdir
from scipy.optimize import minimize
from sys import argv 
from time import time

# Applicable json file name with parameters
input_parameters_file_name = argv[1]

# Initialize the random number generator
rng = random.default_rng()

# Reads in the 
with open(input_parameters_file_name, 'r') as input:
    parameters = json.load(input)


class Priority_Optimizer:
    """ Contains the functions required to produce an optimal set of priorities for a given set of orders and cloud values """

    def __init__(self) -> None:

        # File locations
        self.active_orders_location = parameters["orders_csv"]
        self.cloud_cover_folder = parameters["clouds_folder"]

        # Optimization related variables
        self.scale = 1e-5
        self.optimization_method = parameters["optimization method"]
        self.optimization_tolerance = parameters["optimization tolerance"]
        self.initial_priorities = parameters["initial priorities"]
        self.bounds = parameters["priority bounds"]
        self.average_prioritizations = []
        self.final_optimal_priorities = []
        self.number_of_dollar_val_buckets = len(parameters["dollar bin breakpoints"]) + 1
        self.pri_scheme_total_dollars = []
        self.prioritizations = []

        # Dataframe related variables
        self.cloud_file_names = [x for x in listdir(self.cloud_cover_folder)]
        self.zero_dollar_customer_values = {int(k): v for k,v in parameters["zero_dollar_cust_dpsqkm"].items()}
        self.MCP_priority_to_dollar_map = {int(k): v for k,v in parameters["MCP_dollar_values"].items()}
        self.dollar_breaks = parameters["dollar bin breakpoints"]
        self.weather_scenarios = parameters["number of weather scenarios"]
        self.test_priorities = parameters["test case priorities"]
        self.predicted_cc_uncertainty = parameters["predicted cloud cover uncertainty"] * 2                     # Standard Deviation of the normal distribution  
        self.cloud_cover_buckets = {}

        # Score Curve Variables
        self.coefficient = .47
        self.powers = 10
        self.range = 100

        # Run initial functions
        self.load_data()
        self.prepare_dataframe()

        
    def load_data(self):
        """ Load the csv files into pandas dataframes """

        # Load orders and image strips .csv files into pandas dataframes
        self.active_orders = pd.read_csv(self.active_orders_location)

        # Create variable to contain the latitudes that have orders in them
        self.active_latitudes = set(self.active_orders.Latitude)

        # Store the min and max of the active latitudes
        self.min_latitude = min(self.active_latitudes)
        self.max_latitude = max(self.active_latitudes)

    def prepare_dataframe(self):
        """ Create and populate all columns required prior to starting the optimization process """

        self.add_columns()
        self.populate_actual_cc()
        self.populate_predicted_cc()
        self.populate_dollar_values()
        self.populate_bucket()

        # Create dictionary template for mapping dollar values to priorities 
        self.dollar_to_pri_map = dict.fromkeys(set(self.active_orders.DollarPerSquare), 0) 

    def add_columns(self):
        """ Add/remove the necessary columns and fill with a placeholder value"""

        # Remove unnecessary column
        self.active_orders.drop(labels=["Unnamed: 0"], axis=1, inplace=True)

        # Add needed columns
        self.active_orders["Bucket"] = -1
        self.active_orders["New_Priority"] = 0
        self.active_orders["Score"] = 0
        self.active_orders["Total_Score"] = 0
        self.active_orders["Scheduled"] = False 
            
    def find_cloud_cover(self, lat, lon):
        """ Given a latitude and longitude this will return the nearest cloud cover value from the PWOT .csv """

        # round the lat and lon to the nearest .25
        lat = round(lat * 4) / 4
        lon = round(lon * 4) / 4

        try:
            # return the single cloud cover value associated with the given lat and lon 
            return self.cloud_cover[(self.cloud_cover.Latitude == lat) & (self.cloud_cover.Longitude == lon)].Value.iloc[0]
        except:
            print("Lat: ", lat, "Lon: ", lon)
    
    def populate_actual_cc(self):
        """ Choose an actual cloud cover score for each order """
        print("Running ", self.weather_scenarios," weather scenarios")
        
        # Create acutal cloud value columns
        for column_number in range(self.weather_scenarios):

            # Load the current PWOT .csv into the cloud cover dataframe
            self.cloud_cover = pd.read_csv('PWOT_CSV\\'+ self.cloud_file_names[column_number])

            # Create a column with the current number in the name and populate with the appropriate cloud cover value for each order based on the cloud cover dataframe
            self.active_orders["Actual_" + str(column_number)] = self.active_orders.apply( lambda x: self.find_cloud_cover(x.Latitude, x.Longitude)/100, axis=1)

    def populate_predicted_cc(self):
        """ Populate the predicted cc column with an estimated amount of cloud cover based on the actual cc """

        # Create list of column names
        for column_number in range(self.weather_scenarios):

            # predicted cc is a random variation (+/- uncertanty) of the actual cc
            self.active_orders["Predicted_" + str(column_number)] = self.active_orders.apply( lambda x: x["Actual_" + str(column_number)] + (rng.standard_normal() * self.predicted_cc_uncertainty), axis=1 )

            # predicted cc must be between 0 and 1
            self.active_orders["Predicted_" + str(column_number)].clip(lower=0, upper=1, inplace=True) 
        
    def populate_dollar_values(self):
        """ Populate DollarPerSquare column with dollar values based on existing dollar value or customer """

        # Use .loc to locate all orders with a customer in the zero dollar dictionary
        # Then set the dollar value equal to the corresponding value in the dictionary using the pandas mapping function based on the customer number
        self.active_orders.loc[self.active_orders.Cust_Num.isin(self.zero_dollar_customer_values.keys()), 'DollarPerSquare'] = self.active_orders.Cust_Num.map(self.zero_dollar_customer_values)

        # There is a very large number of cust 306 orders so changing these based on priority will provide a much better model
        # For cust 306 change the dollar value based on priority using the MCP dollar mapping
        self.active_orders.loc[self.active_orders.Cust_Num == 306, 'DollarPerSquare'] = self.active_orders.Task_Pri.map(self.MCP_priority_to_dollar_map) 

    def populate_bucket(self):
        """ Each order is given a bucket number based on the dollar value of the order """

        def bucketing_function(dollar_value):
            """ Returns a bucket value given a dollar value """
            
            if dollar_value <= self.dollar_breaks[10]: return 0
            if (dollar_value >  self.dollar_breaks[10]) and (dollar_value <= self.dollar_breaks[9]):  return 1
            if (dollar_value >  self.dollar_breaks[9]) and (dollar_value <= self.dollar_breaks[8]):  return 2
            if (dollar_value >  self.dollar_breaks[8]) and (dollar_value <= self.dollar_breaks[7]):  return 3
            if (dollar_value >  self.dollar_breaks[7]) and (dollar_value <= self.dollar_breaks[6]):  return 4
            if (dollar_value >  self.dollar_breaks[6]) and (dollar_value <= self.dollar_breaks[5]):  return 5
            if (dollar_value >  self.dollar_breaks[5]) and (dollar_value <= self.dollar_breaks[4]):  return 6
            if (dollar_value >  self.dollar_breaks[4]) and (dollar_value <= self.dollar_breaks[3]):  return 7
            if (dollar_value >  self.dollar_breaks[3]) and (dollar_value <= self.dollar_breaks[2]):  return 8
            if (dollar_value >  self.dollar_breaks[2]) and (dollar_value <= self.dollar_breaks[1]):  return 9
            if (dollar_value >  self.dollar_breaks[1]) and (dollar_value <= self.dollar_breaks[0]):  return 10
            if dollar_value > self.dollar_breaks[0]: return 11
            
        self.active_orders.Bucket = self.active_orders.apply( lambda x: bucketing_function(x.DollarPerSquare), axis=1)

    def populate_priority(self, priority_list):
        """ Add a priority to each order based on the value bucket"""

        # Create a list of tuples where the tuple elements are (bucket, priority)
        bucket_priority_list = []

        for bucket in range(self.number_of_dollar_val_buckets):
            bucket_priority_list.append((bucket, priority_list[-bucket]))

        # Create a dictionary using the list of tuples with key/value pairs of bucket/priority
        bucket_to_pri_map = dict(bucket_priority_list)
        
        # Set the priority value equal to the corresponding value in the dictionary using the pandas mapping function based on the dollar value
        self.active_orders.New_Priority = self.active_orders.Bucket.map(bucket_to_pri_map)

    def priority_to_score(self, priority):
        """ Given a priority will return a score based on the FOM curve"""

        # mathematical conversion from the priority to the score
        return exp(self.coefficient*(self.powers-(5*priority)/self.range))

    def populate_score(self):
        """ populate a score to each order based on the priority of the order """

        # Set the score
        self.active_orders.Score = self.active_orders.apply( lambda x: self.priority_to_score((x.New_Priority)-700), axis=1)

    def populate_total_score(self, weather_column):
        """ Populate a column for total score which is the score multiplied by the predicted cloud cover """

        # Set the total score
        self.active_orders.Total_Score = self.active_orders.apply( lambda x: (1 - x["Predicted_" + str(weather_column)]) * x.Score, axis=1)
    
    def schedule_orders(self):
        """ Return the list of orders that have the maximum score within their respective 2 degree lat """

        latitude = self.min_latitude

        while latitude < self.max_latitude + 1:
            
            # Create the list of orders within the current latitude band
            order_list = self.active_orders[(self.active_orders.Latitude > latitude) & (self.active_orders.Latitude < latitude + 1)]
            
            if not order_list.empty:
                max_index = order_list.Total_Score.idxmax()
                self.active_orders.iloc[max_index, 10 ] = True

            latitude += 2                                                                                         
    
    def total_dollars(self, weather_column):
        """ Returns the sum of all the dollars per square with actual CC value less than the max cc """

        total_dollars = self.active_orders.DollarPerSquare[  (self.active_orders.Scheduled == True) & 
                                                    (self.active_orders.MAX_CC > self.active_orders["Actual_" + str(weather_column)])].sum()
        
        self.pri_scheme_total_dollars.append(total_dollars)

        return total_dollars

    def run_scenario(self, weather_column):
        """ This will reassign each order with a random weather prediction and then reschedule orders accordingly and return a total dollar amount """

        # Reset the schedule by setting all 'Scheduled' to False
        self.active_orders.Scheduled = False

        # Calculate the total score and which orders are scheduled
        self.populate_total_score(weather_column)
        self.schedule_orders()

        return self.total_dollars(weather_column)

    def run_priority_scheme(self, priority_scheme, weather_column):
        """ Will run the set number of scenarios with a given prioritization scheme and return the average total dollar value """

        # Apply the given priority values to the orders
        self.populate_priority(priority_scheme)
        self.populate_score()

        total = self.run_scenario(weather_column)
        
        return - total
    
    def optimal_priorities(self, weather_column):
        """ Uses the SciPy optimization tools to find the optimal prioritization scheme to maximize revenue for a given clear scenario """

        scaled_bounds = [ (x * self.scale, y * self.scale) for x, y in self.bounds ]        # Note: Can't be used with BFGS method (bounds=scaled_bounds,)
        scaled_initial_priorities = [x * self.scale for x in self.initial_priorities ]


        result = minimize(self.run_priority_scheme, 
                          scaled_initial_priorities, 
                          args=weather_column,
                          bounds=scaled_bounds, 
                          tol=self.optimization_tolerance, 
                          method=self.optimization_method)

        if result.success:
            return result
        else:
            raise ValueError(result.message)

    def run_weather_scenarios(self):
        """ This will run the 'run clear scenarios' function for multiple weather scenarios and return an average prioritization from the results"""

        prioritizations = []

        for weather_column in range(self.weather_scenarios):

            # Timing 
            start_time = time()

            # Reset the list of total dollar values
            self.pri_scheme_total_dollars = []

            optimization_result = self.optimal_priorities(weather_column)
            self.prioritizations.append([x / self.scale for x in optimization_result.x])

            # Timing and readout
            end_time = time()
            print("\n----------------------------------------------------------------")
            print("Time elapsed for a weather scenario: ", end_time - start_time)
            print("Prioritization: ", self.prioritizations[-1])
            print("Average $ value: $", sum(self.pri_scheme_total_dollars)/len(self.pri_scheme_total_dollars))
            print("Scenarios tried: ", len(self.pri_scheme_total_dollars))
            print("Final $ value: $", -optimization_result.fun)
            print("----------------------------------------------------------------")



        # Save the average of the prioritization sets found as the final result
        self.final_optimal_priorities = [(sum(x)/len(x)) for x in zip(*self.prioritizations)]

    def run_test_case(self):
        """ Will run the priority_scheme function for the test case priority set """

        total_dollars_for_each_weather_scenario = []

        for weather_column in range(self.weather_scenarios):
            # Produce a total dollar value for a given weather scenario (column) and append to a list
            total_dollars_for_each_weather_scenario.append(self.run_priority_scheme(self.test_priorities, weather_column))

        # Return the average total dollar value
        return sum(total_dollars_for_each_weather_scenario)/len(total_dollars_for_each_weather_scenario)

    def display_results(self):
        """ Will print the resulting optimal priority set as well as display a graph of the same """

        print("\n\nThe final prioritization is: ", self.final_optimal_priorities)

        x_axis = [30] + self.dollar_breaks

        for prioritiztion in self.prioritizations:
            plt.plot(x_axis, prioritiztion, color='lavender', linestyle='solid')

        plt.plot(x_axis, self.final_optimal_priorities, 'o-r')
        plt.show()


if __name__ == "__main__":
    
    # Create calculator object
    priority_optimizer = Priority_Optimizer()
    priority_optimizer.run_weather_scenarios()
    # print(priority_optimizer.run_test_case())
    priority_optimizer.active_orders.to_csv('output_from_pri_scheme.csv')
    priority_optimizer.display_results()





# Ideas
"""
- Make the curve easy to change
- Vet the current output and investigate
- Make easy to change the number of pri bins

+ Use PWOT weather file for weather data
    + Create a trimmed PWOT .csv file
    + Use PWOT to assign cc value to each order

+ Contain the use of self.scale to only values entering and exiting the optimizer function
- Create a Readout function prior to running the scenarios
+ Add an Average readout to each optimizer run
+ Add all prioritiztions to the resulting graph in gray and the average in red
"""